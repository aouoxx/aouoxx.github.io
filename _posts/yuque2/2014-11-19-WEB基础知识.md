---
layout: post
title: web基础知识
categories: [web]
description: web基础知识的介绍,cookie,session的相关信息
keywords: web, cookie, seession
---

<meta name="referrer" content="no-referrer"/>

### cookie 的使用

```java
会话的概念
会话简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，整个过程称之为一个回话

保存回话数据的两种技术：
cookie 客户端技术
	程序把每个用户的数据以cookie的形式写给用户各自的浏览器。
    当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。
    这样web资源处理的就是用户各自的数据了
Session  Session是服务器端技术，
    利用这个技术，服务器在运行时，可以为每个用户浏览器创建一个其独享的session对象，
    由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的Session
中，当用户再去访问服务器中的其他web资源时，其他web资源再从用户各自的Session中取出数据为用户服务
```

​

​

​

```java

Cookie(String name, String   value)
    实例化Cookie对象，传入cooke名称和cookie的值
public String getName()
    取得Cookie的名字
public String getValue()
    取得Cookie的值
public void setValue(String newValue)
    设置Cookie的值
public int getMaxAge()
    获取Cookies的有效期
public String getPath()
    获取cookie的有效路径
public void setDomain(String pattern)
    设置cookie的有效域
public String getDomain()
    获取cookie的有效域

public void setPath(String uri)
    设置cookie的有效路径，比如把cookie的有效路径设置为"/xdp"，那么浏览器访问"xdp"目录下的web资源时，都会带上cookie，
    再比如把cookie的有效路径设置为"/xdp/gacl"，那么浏览器只有在访问"xdp"目录下的"gacl"这个目录里面的web资源时才会带上cookie一起访问，而当访问"xdp"目录下的web资源时，浏览器是不带cookie的

public void setMaxAge(int expiry)
    设置Cookie的最大保存时间，即cookie的有效期，当服务器给浏览器回送一个cookie时，如果在服务器端没有调用setMaxAge方法设置cookie的有效期，那么cookie的有效期只在一次会话过程中有效，
用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一次会话，当用户关闭浏览器，会话就结束了，此时cookie就会失效，
如果在服务器端使用setMaxAge方法设置了cookie的有效期，比如设置了30分钟，那么当服务器把cookie发送给浏览器时，此时cookie就会在客户端的硬盘上存储30分钟，在30分钟内，即使浏览器关了，
cookie依然存在，在30分钟内，打开浏览器访问服务器时，浏览器都会把cookie一起带上，这样就可以在服务器端获取到客户端浏览器传递过来的cookie里面的信息了，这就是cookie设置maxAge和不设置maxAge的区别，
不设置maxAge，那么cookie就只在一次会话中有效，一旦用户关闭了浏览器，那么cookie就没有了，那么浏览器是怎么做到这一点的呢，我们启动一个浏览器，就相当于启动一个应用程序，
而服务器回送的cookie首先是存在浏览器的缓存中的，当浏览器关闭时，浏览器的缓存自然就没有了，所以存储在缓存中的cookie自然就被清掉了，而如果设置了cookie的有效期，那么浏览器在关闭时，
就会把缓存中的cookie写到硬盘上存储起来，这样cookie就能够一直存在了。

```

​

​

> *response 接口也定义了一个 addCookie 方法，它用于在其响应头中增加一个响应的 Set-Cookie 头字段。同样，request 接口中也定义了一个 getCookies 方法，它用于获取客户端提交的 Cookie*​

​

#### cookie 是什么

```java
 cookie是一小文本信息，伴随用户请求在web服务器和浏览器之间传递。用户每次访问站点的时候，
 web应用程序都可以读取cookie包含的信息，在用户请求网站某页面时，应用程序不仅返回请求页面，同时也返回一个包含日期和时间的cookie。
 该cookie可能会保存在客户端的cookie文件夹中。
```

#### cookie 的限制

```java
大多浏览器之处最多可达4096字节(大约4KB)cookie，浏览器还限制一个站点可以在客户端保存的cookie数。
大多数浏览器允许每个站点最多放20个cookie。如果试图保存更多的cookie，那么
先前保存的cookie将被删除。还有的浏览器对来自所有站点的cookie总数限制，这个通常为300个
```

​

#### cookie 的创建

```java
创建cookie的时候要指定几个值，首先指定cookie的名字和要保存的值。可以创建多个cookie。
但每个cookie的名字必须唯一，以便日后取值时识别cookie是按名字存储的，
所以如果创建两个名称相同的cookie，那么最后那个cookie将覆盖前一个
```

​

​

#### cookie 的持久性

```java
如果不设置过期时间，则表示cookie的声明周期为浏览器的回话期间，只要关闭浏览器窗口或则回话超时cookie就消失了。
这种生命期为浏览器回话期的cookie称为会话cookie会话cookie一般不保存在硬盘上而是保存在内存里
如果设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器这些cookie依然有效直到超过设定的过期时间。

当用户下次访问的站点的时候，浏览器会先检查站点的所有cookie，如果某个cookie已经过期，浏览器不会把这个cookie随页面请求一起发送给服务器，而是删除这个已经过期的cookie。
(程序可以在用户磁盘上，写入多个cookie,但每个cookie的过期日期和时间不同)
存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存中的cookie，不同的浏览器有不同的处理方式
```

​

#### cookie 的发送

```java
创建cookie对象 >设置最大时效 >将cookie放入到HTTP响应报头
如果你创建了一个cookie，并将他发送到浏览器默认情况下它是一个回话级别的cookie，存储在浏览器的内存中，用户退出浏览器之后被删除。
如果你希望浏览器将该cookie存储在磁盘上，则需要使用maxAge
并给出一个以秒为单位的时间。将最大时效设置为0则是命令浏览器删除该cookie

cookie的发送需要使用HttpServeltResponse的addCookie方法，将cookie插入到一个set-cookiehttp请求包头中，
由于这个方法并不修改任何之前指定的set-cookie而是创建新的报头，因此我们将这个方法称为是addCookie，而非setCookie

```

​

#### cookie 的读取

```java
通过调用HttpServeltRequest的getCookies方法，可获得Cookie的对象数组，对应Http请求中Cookie包头输入的值。
对数组进行循环，调用每个Cookie的getName方法直到找到感兴趣的cookie位置
@WebServlet(name="cookie" ,urlPatterns="/cookie/*")
public class CookieDemo extends HttpServlet {
@Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                      throws ServletException, IOException {

              resp.setCharacterEncoding( "UTF-8");//设置服务器以UTF-8编码输出
              resp.setContentType( "text/html;charset=UTF-8");
              PrintWriter out = resp.getWriter();
               //获取浏览器范文服务器时传递过来的cookie数组
              Cookie[] cookies = req.getCookies();
               if(cookies!=null){
                     out.println( "您上次访问的时间：" );
                      for(int i=0;i<cookies.length;i++){
                           Cookie cookie = cookies[i];
                            if(cookie.getName().equals("lastAccessTime" )){
                                  Long lastAccessTime = Long.parseLong(cookie.getValue());
                                  Date date = new Date(lastAccessTime);
                                  out.println(date);
                           }

                     }
              } else{
                     out.println( "这是您第一次登陆本站" );
              }

               //用户访问过之后重新设置用户的访问时间，存储到cookie中，然后发送到客户端浏览器
               //创建一个cookie,cookie的名字是lastAccessTime
              Cookie cookie = new Cookie("lastAccessTime" , System.currentTimeMillis()+"");
              resp.addCookie(cookie);
       }

        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp)
                      throws ServletException, IOException {
              doGet(req, resp);
       }
}
```

![image.png](https://cdn.nlark.com/yuque/0/2021/png/659846/1635722964718-8e06dd3a-9ee4-4beb-96d5-7d53e9d6a24a.png#clientId=ud9602aa2-8379-4&from=paste&height=356&id=u3c11ba48&margin=%5Bobject%20Object%5D&name=image.png&originHeight=494&originWidth=1167&originalType=binary&ratio=1&size=86943&status=done&style=none&taskId=u4c0d65c6-e170-4dad-b01e-08ea58357ff&width=841.5)

> *设置 Cookie 的有效期为一天*​
> *cookie.setMaxAge(24*60*60)*​

![image.png](https://cdn.nlark.com/yuque/0/2021/png/659846/1635723169961-e35bc47a-0d3e-489c-8c30-bd514204b8f6.png#clientId=ud9602aa2-8379-4&from=paste&height=359&id=u87af344c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=496&originWidth=1175&originalType=binary&ratio=1&size=110941&status=done&style=none&taskId=u41fd9ee3-a765-4c56-8897-808a2b549ab&width=849.5)

#### 删除 cookie

```java
Cookie cookie = new Cookie("lastAccessTime",System.currentTimeMillis()+"");
//设置Cookie的有效期为0，命令浏览器删除该Cookie
cookie.setMaxAge(0);
response.addCookie(cookie);
```

![image.png](https://cdn.nlark.com/yuque/0/2021/png/659846/1635723218685-cd0cc110-2ee5-49dd-bfe0-12a9f1da9956.png#clientId=ud9602aa2-8379-4&from=paste&height=283&id=u56dd108c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=385&originWidth=1175&originalType=binary&ratio=1&size=63948&status=done&style=none&taskId=ue451f94e-adf5-43d6-aba7-692f8179c9d&width=862.5)

#### cookie 中存取中文

```java
要想在cookie中存储中文，那么必须使用URLEncoder类里面的encode（String s, String enc）方法进行中文转码
Cookie cookie = new Cookie("userName",URLEncoder.encode("孤傲苍狼"，“utf-8”));
response.addCookie(cookie)
在获取cookie中的中文数据时，在使用URLDecoder类里面的decode(String s, String enc)进行解码，例如：
URLDecoder.decode(cookies[i].getValue(),'UTF-8');
```

#### cookie 的其他注意

```java
Cookie的注意细节
1）一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称NAME和设置值（VALUE）
2）一个web站点可以给WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEN站点提供的Cookie
3）浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB
4）如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie（即存储在浏览器的内存中），用户退出浏览器之后即被删除。
若希望浏览器将该cookie存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间。将最大时效设为0则是命令浏览器删除该cookie。

```

### session 的介绍

```java
WEB开发中，服务器可以为每个用户浏览器创建一个会话对象(Session)对象，注意一个浏览器独占一个session对象。
因此在需要保存用户数据是，服务器程序可以把用户数据写到用户浏览器
独占的Session中，当用户使用浏览器访问其他程序时，其他程序可以从用户的session中取出该用户的数据，为用户服务

```

#### session 的特点

```java
Cookie是把用户数据写给用户的浏览器
Session技术是把用户的数据数据写到用户独占的session
Session对象有服务器创建，可以调用request对象的getSession方法得到Session对象。
```

#### httpsession 的常见问题

```java
Session的创建的时间
一个常见的误解是以为session在有客户端访问的时候就被创建了，
 实际上是直到某个server端程序调用HttpServletRequest.getSession（true）这样的语句才被创建，注意如果JSP没有显示的使用
<% @page session="false" %>关闭session，
  则JSP文件在编译成Servlet时，将会自动加上这样一条语句
    HttpSession session=HttpSessionRequest.getSession(true);
这也是JSP中隐含的session对象的来历
由于session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它

```

#### session 何时删除

```java
调用程序HttpSession.invalidate()
距离上一次收到客户端发送的session id时间间隔超过了session的超时设置
服务器进程被停止(非持久session)

如何做到在浏览器关闭的时候删除session严格的讲，做不到这一点。
可以做一点努力的办法是在所有的客户端页面里面使用javascript代码
window.onclose（）来监视浏览器的动作，然后向服务器发送一个请求来删除session。
但是对于浏览器崩溃和强行杀死进程这些非常规的手段无能为力
```

##### httpsessionlistener 是怎么回事

```java
可以创建这样的Listenter去监控session的创建和销毁事件，使得在发生事件时可以做一些相应的工作。
注意是session的创建和销毁动作触发listener，而不是相反，类似的与HttpSession相关的Listener还有
HttpSessionBindingListener,HttpSessionActivationListener,和HttpSessionAttiributeListener

    HttpSessionListener
        在session创建和销毁时用(StandardSession.setId(),StandardSession.expire())
    HttpSessionActivationListener
        在session钝化和反钝化时用(StandardSession.doUnload(),StandardSession.doload())
    HttpSessionAttributeListener
        在session的attributes属性发生变化时
```

##### 存放 session 中对象必须是可序列化么

```java
不是必须的。
要求对象序列化只是为了session能够在集群中被复制或者能够持久保存或必要时server能够展示把session交换出内存，

```

##### session 存放在哪里

```java
服务器端的内存中。不过session可以通过特殊的方式做持久化管理.
```

##### session 的 ID 是从哪里来的

```java
essionID是如何使用的，当客户端第一次请求session对象时候，服务器会为客户端创建一个session，并将通过特殊的算法算出一个session的ID，用来标识该session对象
当浏览器下次(session继续有效时)请求别的资源的时候浏览器会偷偷将sessionID放置到请求头中，
	服务器接受到请求后就得到该请求的sessionID,服务器找到该id的session返回给请求servelt使用。
一个回话只能有一个session管理，对session来说是只认id不认人

session因为请求（request对象）而产生,同一个会话中多个request共享了一session对象,可以直接从请求中获取到session对象。
session的创建和使用总在服务端，而浏览器从来都没有得到过session对象。
但浏览器可以请求Servlet(jsp也是Servlet)来获取session信息。
客户端浏览器真正紧紧拿到的是session ID,而对于这个浏览器操作的人来说是不可见的，并且用户也无需关心自己处于哪个回话中.
```

#### session 的生成

```java
Session对象的创建一般是源于这样语句
Session session = request.getSession(false);  或者 Session session = request.getSession();如果不在乎服务器压力可能多那么一点点
在Tomcat的实现中，这个request是org.apache.catalina,connector.Request类的包装类

org.apache.catalina.connector.RequestFacade的对象，它的两个getSession的方法如下：

public HttpSession getSession(boolean create){
    if (this .request == null) {
        throw new IllegalStateException(sm.getString("requestFacade.nullRequest"));
    }

    if (SecurityUtil.isPackageProtectionEnabled()) {
        return (HttpSession)AccessController.doPrivileged( new GetSessionPrivilegedAction(create));
    }

    return this .request.getSession(create);
}

public HttpSession getSession(){
    if (this .request == null) {
        throw new IllegalStateException(sm.getString("requestFacade.nullRequest"));
    }

    return getSession(true);
}

最后进入org.apache.catalina,connector.Request的getSession（）方法

public HttpSession getSession(){
    Session session = doGetSession (true );
    if (session == null) {
        return null ;
       }
    return session.getSession();
}

public HttpSession getSession(boolean create){
    Session session = doGetSession (create);
    if (session == null) {
        return null ;
    }

    return session.getSession();
}

跳转到doGetSession()这个方法

protected Session doGetSession( boolean create)
         {
          //没有Context的话直接返回null
           if (this .context == null) {
             return null ;
           }
           // 判断Session是否有效
           if ((this .session != null) && (!this.session .isValid())) {
             this.session = null;
           }
           if (this .session != null) {
             return this .session;
           }

          // 返回Manager对象，这里是StandardManager类的对象
           Manager manager = null;
           if (this .context != null) {
             manager = this.context.getManager();
           }
           if (manager == null)
           {
             return null ;
           }
            // 判断是否有SessionID
           if (this .requestedSessionId != null ) {
             try {
           // 在Manager中根据SessionID查找Session
               this.session = manager.findSession( this.requestedSessionId);
             } catch (IOException e) {
               this.session = null;
             }
             if ((this .session != null) && (!this.session .isValid())) {
               this.session = null;
             }
             if (this .session != null) {
               // 更新访问时间
               this.session.access();
               return this .session;
             }

           }

          // 创建新的Session
           if (!create) {
             return null ;
           }
           if ((this .context != null) && (this.response != null ) && (this.context.getServletContext().getEffectiveSessionTrackingModes().contains( SessionTrackingMode.COOKIE)) && (this.response.getResponse().isCommitted()))
           {
             throw new IllegalStateException(sm.getString("coyoteRequest.sessionCreateCommitted"));
           }

          // 判断是否使用 "/" 作为Session Cookie的存储路径 并且 是否SessionID来自Cookie
           if ((("/" .equals(this.context .getSessionCookiePath())) && (isRequestedSessionIdFromCookie())) || ( this.requestedSessionSSL))
           {
          // 创建Session
             this.session = manager.createSession( getRequestedSessionId());
           }
           else this .session = manager.createSession( null);

           // 创建一个新的Session Cookies
           if ((this .session != null) && (getContext() != null) && (getContext().getServletContext().getEffectiveSessionTrackingModes().contains( SessionTrackingMode.COOKIE)))
           {
                // 配置Session Cookie
             Cookie cookie = ApplicationSessionCookieConfig.createSessionCookie( this.context, this.session.getIdInternal(), isSecure());
               // 在响应中加入Session Cookie
             this.response.addSessionCookieInternal(cookie);
           }

           if (this .session == null) {
             return null ;
           }
          // 更新访问时间
           this.session.access();
           return this .session;
         }

该方法说明了Tomcat创建的大体过程，
	首先判断requestSessionId是否存在，如果存在那么根据这个ID去查找session对象。
    如果requestSessionId不存在或者没有取到Session，并且传递给getSession(boolean)的参数为真
    那么要创建一个新的Session，并且写给客户端一个Session Cookie

困惑requestedSessionId的赋值是什么时候赋值的呢？

	查看Tomcat的请求处理过程，请求曾到过这一步：
    	org.apache.catalina.connector.CoyoteAdapter的 server()方法。
	方法 postParseRequest(req.resp,res,response)。
    就是这一步处理了SessionID的获取，
    	这个方法调用了#parseSessionId（)和parseSessionCookiesId( )这两个方法,就是它会sessionID进行了提取



```

```java
protected void parseSessionCookiesId(org.apache.coyote.Request req, Request request)
         {
           Context context = (Context )request.getMappingData().context;
           if ((context != null) && (!context.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode .COOKIE)))
           {
             return;
           }
            // 返回Cookie
           Cookies serverCookies = req.getCookies();
           int count = serverCookies.getCookieCount();
           if (count <= 0) {
             return;
           }

           String sessionCookieName = SessionConfig.getSessionCookieName(context);

           for (int i = 0; i < count; i++) {
             ServerCookie scookie = serverCookies.getCookie(i);
           // 判断是否有JSESSIONID这个名字的Cookie
             if (scookie.getName().equals(sessionCookieName))
             {
               if (!request.isRequestedSessionIdFromCookie())
               {
                 convertMB(scookie.getValue());
                 request.setRequestedSessionId(scookie.getValue().toString());

                // 设定Session ID
                 request.setRequestedSessionCookie( true);
                 request.setRequestedSessionURL( false);
                 // 如果之前在URL中读到了SessionID，那么会覆盖它
                 if (log.isDebugEnabled()) {
                   log.debug(" Requested cookie session id is " + request.getRequestedSessionId());
                 }

               }
               else if (!request.isRequestedSessionIdValid())
               {
                 convertMB(scookie.getValue());
                 request.setRequestedSessionId(scookie.getValue().toString());
               }
             }
           }
         }
```

#### session 对象的创建机制

```java
在程序中第一次调用request.getSession()方法就会创建一个新的Session，可以用isNew（）来判断session是不是新创建的

//使用request对象的getSession（）获取session，如果session不存在则创建一个
HttpSession session = request.getSession( );
//获取sessionId
String sessionId = session.getId();
//判断session是不是新创建的
if（session.isNew()）{
     response.getWriter().print("session 创建成功，session的id是："+sessionId);
}else{
     response.getWriter().println("服务器已经存在session，sesssionId是："+sessionId);
}
```

##### session 对象的销毁机制

```java
Session对象默认30分钟没有使用就会自动销毁，可以在web.xml文件中手工的配置session的失效时间
 <!-- 设置Session的有效时间:以分钟为单位-->
   <session-config>
         <session-timeout>15</session-timeout>
   </session-config>
当需要程序中手动设置Session失效时，可以手工调用session.invalidate方法，摧毁session
HttpSession session = request.getSession( );
//手工调用session.invalidate方法，摧毁session
session.invalidate()

```

##### session 的时效时间的三种设置方法

```java
1）web app server 中，如 websphere 里可以设置超时时间诶30分钟
2）在web.xml中的session-config配置
     session-timeout元素（WEB.XML文件中的元素）用来执行默认的回话超时时间间隔，以分钟为单位。该元素之必须为整数。如果session-timeout
元素的值为0或者负数，则表示永远不会超时。
  <session-config>
         <session-timeout>15</session-timeout>
  </session-config>
3）java 代码设置
setMaxInactiveInterval设置的是当前回话的失效时间，不是真个web时间，单位以秒计算。如果没有设置的值为0或者为负数，则表示回话将永远不会关闭。
常用设置当前回话使劲
session.setMaxInactiveInterval(30*60)
```

#### session 的使用

##### session 防止表单重复提交

```html
表单重复提交的场景
1）场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交 (
可以使用JAVASCRIPT脚本来控制 )
2）场景二：表单提交后用户点击【刷新】按钮导致表单重复提交
3）场景三：用户提交表单后，点击浏览器的【后退】按钮回到表单页面后进行再次提交
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Insert title here</title>
  </head>
  <body>
    <form action="/Servlet/session/DoFormServlet" method="post">
      用户名： <input type="text" name="username" />
      <input type="submit" value="提交" id="submit" />
    </form>
  </body>
</html>
```

```java
@WebServlet(name="SESSION" ,urlPatterns="/session/DoFormServlet")
public class SessionForm extends HttpServlet {

        private static final long serialVersionUID = 1L;

        public void doGet(HttpServletRequest request, HttpServletResponse response)
                    throws ServletException, IOException {
                //客户端是以UTF-8编码传输数据到服务器端的，所以需要设置服务器端以UTF-8的编码进行接收，否则对于中文数据就会产生乱码
                request.setCharacterEncoding( "UTF-8");
                String userName = request.getParameter( "username");
                try {
                    //让当前的线程睡眠3秒钟，模拟网络延迟而导致表单重复提交的现象
                    Thread. sleep(3*1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System. out.println("向数据库中插入数据：" +userName);
            }

        public void doPost(HttpServletRequest request, HttpServletResponse response)
                    throws ServletException, IOException {
               doGet(request, response);
           }
}
```

###### 利用 JAVAScript 防止表单重复提交

```java
利用JAVAScript防止表单重复提交，做法就是JAVAScript控制Form表单只能提交一次
<!DOCTYPE html>
<html>
<head>
<meta charset= "UTF-8">
<title> Insert title here</title >
</head>
<script type= "text/javascript">
        var isCommitted = false;//表单是否已经提交标识，默认为false
        function doSubmit(){
                 if(isCommitted==false)
                 {
                        isCommitted = true;//提交表单后，将表单是否已经提交标识设置为true
                         return true ;//返回true让表单正常提交
                 } else{
                         return false ;//返回false那么表单将不提交
                 }
       }

        function doSubmit2(){
               var btnSubmit = document.getElementById("submit" );
               //将表单提交按钮设置为不可用，这样就可以避免用户再次点击提交按钮
                btnSubmit.disabled= "disabled";
               //返回true让表单可以正常提交
               return true ;

       }
</script>
<body>
        <form action= "/Servlet/session/DoFormServlet" onsubmit="doSubmit2();" method="post" >
              用户名： <input type= "text" name ="username">
               <input type= "submit" value ="提交" id= "submit">
        </form>
</body>
</html>
```

###### 利用 session 防止表单重复提交

```java
对于上述场景二和场景三导致的重复提交，在客户端是无法解决的，只能在服务端使用SESSION来完成
具体的做法：
     在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。
然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，
然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。
如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。

下面几种情况，服务器拒绝处理用户提交的请求：
1) 存储Session域中的Token令牌和表单提交的Token令牌不同
2)当前用户的Session中不存在Token令牌
3)用户提交的表单数据中没有Token令牌
```

```java
1) FormServlet 用于生成Token(令牌)和跳转到form.jsp页面
@WebServlet(name="SESSION" ,urlPatterns="/session/sessionForm")
public class SessionForm extends HttpServlet {

        private static final long serialVersionUID = 1L;

        public void doGet(HttpServletRequest request, HttpServletResponse response)
                    throws ServletException, IOException {
                     String token = TokenProcessor. getInstance().makeToken();//创建令牌
                     System. out.println("在FormServlet中生成的token：" +token);
                     request.getSession().setAttribute( "token", token);  //在服务器使用session保存token(令牌)
                     request.getRequestDispatcher( "/sessionp/form.jsp").forward(request, response);//跳转到form.jsp页面

            }

        public void doPost(HttpServletRequest request, HttpServletResponse response)
                    throws ServletException, IOException {
               doGet(request, response);
           }
}
```

```java
2) 后台生成的Token传递到前台页面中
<%@ page language="java" contentType="text/html; charset=utf-8"
    pageEncoding= "utf-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd" >
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title> Insert title here</title >
</head>
<body>

  <form action="/Servlet/session/doFormServlet" method ="post">
               <input type= "hidden" name ="token" value="${token} "/>
              用户名： <input type= "text" name ="username">
               <input type= "submit" value ="提交" id= "submit">
        </form>

</body>
</html>
```

![image.png](https://cdn.nlark.com/yuque/0/2021/png/659846/1635733751426-f4c4fc3d-b08a-4d88-ab8c-7984e55861ca.png#clientId=ua71ffd24-cc51-4&from=paste&height=140&id=u55e80a72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=205&originWidth=1163&originalType=binary&ratio=1&size=27447&status=done&style=none&taskId=ub31feb3f-ef8e-4ccd-975b-6407f0fee80&width=791.5)

```java
3）用于处理提交的表单
@WebServlet(name="dosession" ,urlPatterns="/session/doSessionForm")
public class DoSessionForm  extends HttpServlet{
        private static final long serialVersionUID = 1L;
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                      throws ServletException, IOException {
               boolean b = isRepeatSubmit(req); //判断是否重读提交了表单
               if(b==true ){
                     System. out.println("请不要重复提交" );
                      return ;
              }
              req.getSession().removeAttribute( "token");//移除session中的token
       }
        private boolean isRepeatSubmit(HttpServletRequest request){

              String client_token = request.getParameter( "token");

               if(client_token==null){
                     System.out.println("required token=null");
                      return true ;
              }
               //去除session中的token
              String server_token = (String) request.getSession().getAttribute("token" );
               //如果当前用户中的Session不存在Token ，则用户重复提交了表单
               if(server_token==null){
                     System.out.println("session token=null");
                      return true ;
              }
               //存储在session中的token和表单中提交的token不同则用户重复提交了表单
               if(!client_token.equals(server_token)){
                     System.out.println(" token still is the same");
                      return true ;
              }
               return false ;
       }

        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp)
                      throws ServletException, IOException {
               // TODO Auto-generated method stub
              doGet(req, resp);
       }
}

```

```java
生成Token对应的值
public class TokenProcessor {

        /**
        * 单利设置模式（保证类的对象在内存中只有一个）
        * 1）把类的构造函数私有
        * 2）自己创建一个类
        * 3）对外提供一个公共的方法，返回类的对象
        */
        private TokenProcessor(){}

        private static final TokenProcessor instance = new TokenProcessor();

        /**
        * 获取对象实例
        */
        public static TokenProcessor getInstance(){
               return instance ;
       }

        /**
        * 生成Token
        */
        public String makeToken(){
              String token=(System. currentTimeMillis()+new Random().nextInt(999999999))+"" ;
               try {
                     MessageDigest md = MessageDigest. getInstance("md5");
                      byte md5[]= md.digest(token.getBytes());
                     BASE64Encoder encoder = new BASE64Encoder();
                      return encoder.encode(md5);
              } catch (Exception e) {
                      throw new RuntimeException(e);
              }

       }

}

```

### 过滤器 fliter 的介绍

#### filter 的简介

```java
Filter也称之为过滤器，是Servlet技术中最激动人心的技术，WEB开发人员通过Filter技术，对WEB服务器管理的所有WEB资源。例如 JSP Servlet,静态图片文件或静态HTML文件等进行拦截，从而实现
一些特殊的功能，例如实现URL级别权限访问控制，过滤敏感词汇，压缩响应信息等一些高级功能

ServletAPI 提供了一个Filter接口，开发WEB应用时，如果编写的JAVA类实现了这个接口，则把JAVA类称之为Filter.通过Filter技术可以实现用户访问某个目标之前对访问的请求和响应进行拦截

Filter是如何实现拦截的
Filter接口中有一个doFilter()方法，我们编写好Filter，并配置web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前，都先调用一下filter的dofilter方法，因此，在该方法内编写
代码，可达到如下目的：
1）调用目标资源之前，让一段代码执行
2）是否调用目标资源(即是否让用户访问web资源)
3）调用目标资源之后，让一段代码执行

web服务器在调用doFilter方法时，会传递一个filtChain对象进来，filtChain对象是filter接口中最重要的一个对象，它也提供了一个doFilter（）方法，开发人员可以根据需求决定是否调用此方法，
调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问，否则web资源不会被访问。

```

```java
public class FilterDemo01 implements Filter {

        @Override
        public void destroy() {
                System. out.println("----过滤器销毁----" );
       }

        @Override
        public void doFilter(ServletRequest arg0, ServletResponse arg1,
                     FilterChain arg2) throws IOException, ServletException {
                //对request和response进行一些预处理
              arg0.setCharacterEncoding( "UTF-8");
              arg1.setCharacterEncoding( "UTF-8");
              arg1.setContentType( "text/html;charset=UTF-8");

              System. out.println("FilterDemo01执行前！！！" );
              arg2.doFilter(arg0, arg1);  //让目标资源执行，放行
              System. out.println("FilterDemo01执行后！！！" );

       }

        @Override
        public void init(FilterConfig arg0) throws ServletException {
                System. out.println("----过滤器初始化----" );
       }

}
```

```java
<filter >
    <filter-name> demo01</ filter-name>
    <filter-class> com.Filter.FilterDemo01</filter-class >
</filter >

<filter-mapping >
    <filter-name> demo01</ filter-name>
      <!-- /* 表示拦截所有请求 -->
   <url-pattern> /*</ url-pattern>
</filter-mapping >
```

##### filter 链

> *一个 web 应用中，可以开发编写多个 Filter，这些 Filter 组合起来称之为 Filter 链 web 服务器根据 Filter 在 web.xml 文件中注册顺序，决定先调用那个 Filter，当第一个 Filter 的 do Filter 方法被调用时，web 服务器会创建一个代表 Filter 链的 FilterChain 对象传递给该方法。在 doFilter 方法中，开发人员如果调用了 FilterChain 对象的 doFilter 方法，则 web 服务器会检查 FilterChain 对象中是否还有 filter，如果有，则调用第二个 filter，如果没有则调用目标资源。*​

```java
<filter>
     <filter-name> demo01</ filter-name>
     <filter-class> com.Filter.FilterDemo01</filter-class >
</filter >

<filter-mapping >
     <filter-name> demo01</ filter-name>
     <!-- /* 表示拦截所有请求 -->
     <url-pattern> /*</ url-pattern>
</filter-mapping >

<filter >
     <filter-name> demo02</ filter-name>
     <filter-class> com.Filter.FilterDemo02</filter-class >
</filter >

<filter-mapping >
     <filter-name> demo02</ filter-name>
     <!-- /* 表示拦截所有请求 -->
     <url-pattern> /*</ url-pattern>
</filter-mapping >
```

##### filter 的工作原理

```java
当客户端发出Web资源的请求时，Web服务器根据应用程序配置文件设置的过滤规则进行检查，若客户请求满足过滤规则，则对客户请求／响应进行拦截，
对请求头和请求数据进行检查或改动，并依次通过过滤器链，最后把请求／响应交给请求的Web资源处理。请求信息在过滤器链中可以被修改，
也可以根据条件让请求不发往资源处理器，并直接向客户机发回一个响应。当资源处理器完成了对资源的处理后，响应信息将逐级逆向返回。
同样在这个过程中，用户可以修改响应信息，从而完成一定的任务。

关于过滤链的问题：上面说了，当一个请求符合某个过滤器的过滤条件时该请求就会交给这个过滤器去处理。那么当两个过滤器同时过滤一个请求时谁先谁后呢？这就涉及到了过滤链FilterChain。
所有的奥秘都在Filter的FilterChain中。服务器会按照web.xml中过滤器定义的先后循序组装成一条链，然后一次执行其中的doFilter()方法。
执行的顺序，执行第一个过滤器的chain.doFilter()之前的代码，第二个过滤器的chain.doFilter()之前的代码，请求的资源，第二个过滤器的chain.doFilter()之后的代码，第一个过滤器的chain.doFilter()之后的代码，最后返回响应。

上面说的“执行请求的资源”究竟是怎么执行的？对于“执行第一个过滤器的chain.doFilter()之前的代码，第二个过滤器的chain.doFilter()之前的代码”这些我可以理解，无非就是按顺序执行一句句的代码，
但对于这个“执行请求的资源”其实是这样的：通常我们所访问的资源是一个servlet或jsp页面，而jsp其实是一个被封装了的servlet，于是我们就可以统一地认为我们每次访问的都是一个Servlet,而每当我们访问一个servlet时，
web容器都会调用该Servlet的service方法去处理请求。而在service方法又会根据请求方式的不同（Get/Post）去调用相应的doGet()或doPost()方法，实际处理请求的就是这个doGet或doPost方法。
在doGet（或doPost）方法中是通过response.getWriter（）得到客户端的输出流对象，然后用此对象对客户进行响应。
到这里我们就应该理解了过滤器的执行流程了：

执行第一个过滤器的chain.doFilter()之前的代码
——>第二个过滤器的chain.doFilter()之前的代码
——>……
——>第n个过滤器的chain.doFilter()之前的代码
——>所请求servlet的service()方法中的代码
——>所请求servlet的doGet()或doPost()方法中的代码
——>第n个过滤器的chain.doFilter()之后的代码
——>……
——>第二个过滤器的chain.doFilter()之后的代码
——>第一个过滤器的chain.doFilter()之后的代码。
```

##### filter 的生命周期

```java
1) Filter的创建
     Filter的创建和销毁由web服务器负责。
     web应用程序启动时，web服务器将创建Filter的实例对象并调用器init方法，完成对象的初始化功能，从而为后续的用户请求做好拦截的准备工作。
     Filter对象只会创建一次init方法也只会执行一次，通过init（）方法的参数，可获得当前filter配置信息的FilterConfig对象

2）Filter的销毁
     web容器调用destory方法销毁Filter.destory方法在Filter方法周期中仅仅执行一次。
     在destory方法中，可以释放过滤器使用的资源。

3）FilterConfig接口
     用户在配置filter时，可以使用<init-param>为Filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了Filter初始化参数的FilterConfig对象传递进来。
     因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得

     String getFilterName();
    		得到filter的名称
     String getInitParameter（String name);
     		返回在部署描述中指定名称的初始化参数的值，如果不存在返回null
     Enumeration getInitParameterNames( );
			返回过滤器的所有参数的名字的枚举集合
     public ServletContext getServletContext();
 			返回Servlet上下文对象的引用

```

```java
 <filter >
     <filter-name> demo02</ filter-name>
     <filter-class> com.Filter.FilterDemo02</filter-class >
           <init-param>
               <description> 名字</description >
               <param-name> name</ param-name>
               <param-value> ssgao</param-value >
          </init-param>
          <init-param>
               <description> 兴趣</description >
               <param-name> like</ param-name>
               <param-value> book</ param-value>
          </init-param>
   </filter >

   <filter-mapping >
         <filter-name> demo02</ filter-name>
         <!-- /* 表示拦截所有请求 -->
          <url-pattern> /*</ url-pattern>
   </filter-mapping >

 @Override
public void init(FilterConfig arg0) throws ServletException {
     System. out.println("----2过滤器初始化----" );
     //得到过滤器的名字
     String filterName = arg0.getFilterName();
     //得到在web。xml稳重配置的初始化参数
     String initParam1 = arg0.getInitParameter( "name");
     String initParam2 = arg0.getInitParameter( "like");

     //返回所有的厨师话参数的枚举集合
     Enumeration<String> initParamterNames = arg0.getInitParameterNames();
     System. out.println(filterName);
     System. out.println(initParam1);
     System. out.println(initParam2);

     while(initParamterNames.hasMoreElements()){
           String paramNameString = (String) initParamterNames.nextElement();
           System. out.println(paramNameString);
     }

}
```

#### filter 的部署

```java
Filter的部署分为下面两个步骤
     1）注册Filter
     2）映射Filter
```

#### filter 的注册

```java
开发好Filter之后，需要在web.xml文件中进行注册，这样才能够被web服务器调用
   <filter>
       <filter-name> demo02</ filter-name>
       <filter-class> com.Filter.FilterDemo02</filter-class >
       <init-param>
            <description> 名字</description >
            <param-name> name</ param-name>
            <param-value> ssgao</param-value >
       </init-param>
   </filter >
     <description>用于添加描述信息，该元素内容可以为空，<description>可以不配置
     <filter-name> 用于为过滤器指定一个名字，该元素的内容不能为空
     <filter-class>  元素用于指定过滤器完整的限定类名
     <init-param> 元素用于为过滤器指定初始化参数，它的子元素<param-name>指定参数的名字   <param-value> 指定参数的值
在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。如果过滤器不需要指定初始化参数，那么<init-param>元素可以不配置

```

#### filter 的映射

```java
 在web.xml文件中，注册了Filter之后，还要在web.xml文件中映射Filter
 <filter-mapping >
               <filter-name> demo02</ filter-name>
               <!-- /* 表示拦截所有请求 -->
               <url-pattern> /*</ url-pattern>
              <dispatcher>REQUEST</dispatcher>
             <dispatcher>FORWARD</dispatcher>
 </filter-mapping >

<filter-mapping>元素用于设置一个Filter所负责拦截的资源。一个Filter拦截资源可通过两种方式来指定：Servlet名称和资源访问的请求路径
<filter-name> 子元素用于设置Filter的注册名称。该值是<filter>元素中声明过的过滤器名字
<url-pattern> 设置Filter所拦截的请求路劲
<servlet-name> 指定过滤器所拦截的Servlet名称
<dispatcher>指定过滤器所拦截的资源被Servlet容器调用的方式，可以是REQUEST,INCLUDE,FORWORD,ERROR之一默认是REQUEST,用户可以设置多个<dispatcher>子元素来指定<Filter>对资源多种调用方式进行拦截

<dispatcher>子元素可以设置的值及其意义：
1）REQUEST: 当用户直接访问页面时,web 容器将会调用过滤器。如果目标资源是通过RequestDispacher的include（）或forword（）方法访问时，那么该过滤器就不会被调用
2）INCLUDE： 如果目标资源通过RequestDispacher的include（）方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用
3）FORWORD: 如果目标资源是通过REQUESTDispacher的forword()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用
4）ERROR:如果目标资源时通过声明异常处理机制调用时，那么该过滤器将被调用。除此之外过滤器不会被调用
```

#### filter 的注解

> *Servlet 3.0 提供@WebFilter 注解将一个实现了 javax.servlet.Filter 接口的类定义为过滤器，这样我们在 web 应用中使用过滤器时，也不再需要在 web.xml 文件中配置*过滤器的相关描述\_​

```java
/**
 *使用注解过滤器
 *@Webfilter将一个实现了javax.servlet.Filter接口的类定义为过滤器
 *属性filerName声明过滤器的名称，可选
 *属性urlPatterns指定要过滤的URL模式，也可使用属性value来声明(指定要过滤的URL模式是必选属性)
 *
 */
@WebFilter(filterName="demo01" ,urlPatterns="/*")
public class FilterDemo01 implements Filter {

        @Override
        public void destroy() {
                System. out.println("----1过滤器销毁----" );
       }

        @Override
        public void doFilter(ServletRequest arg0, ServletResponse arg1,
                     FilterChain arg2) throws IOException, ServletException {
                //对request和response进行一些预处理
              arg0.setCharacterEncoding( "UTF-8");
              arg1.setCharacterEncoding( "UTF-8");
              arg1.setContentType( "text/html;charset=UTF-8");

              System. out.println("FilterDemo01执行前！！！" );
              arg2.doFilter(arg0, arg1);  //让目标资源执行，放行
              System. out.println("FilterDemo01执行后！！！" );

       }

        @Override
        public void init(FilterConfig arg0) throws ServletException {
                System. out.println("----1过滤器初始化----" );
       }

}


```

```java
含有初始化删除的注解


@WebFilter(
    	 urlPatterns ={"/servlet/*" },
         asyncSupported= true,
         dispatcherTypes={DispatcherType.REQUEST},
         initParams=@WebInitParam (name= "param1", value= "value1"))
public class ExampleFilter implements Filter {

   @Override
   public void destroy() {
      System. out.println("destory filter……" );
   }

   @Override
   public void doFilter(ServletRequest request, ServletResponse response,
         FilterChain chain) throws IOException, ServletException {
      System. out.println("filter……" );
      chain.doFilter(request, response);
   }

   @Override
   public void init(FilterConfig filterConfig) throws ServletException {
      String param1 = filterConfig.getInitParameter( "param1");
      System. out.println("filter init……" + param1);
   }
}
```

### 监听器 listener 的介绍

```java
监听器就是一个实现特定接口的普通java程序，这个程序专门用于监听另外一个java对象的方法调用或属性的改变，
当被监听的对象发生上述事件后，监听器某个方法将被立即执行.

监听器是一个专门用于对其他对象身上发生的事件或状态改变进行监听相应处理的对象，当被监视的对象发生情况时，立即采用相应的行动。
监听器其实就是一个现实特定接口的普通JAVA程序，这个程序专门用于监听JAVA对象的方法调用或属性改变，
当被监听对象发生上述事件后，监听器的某个方法立即被执行

```

#### web 中的监听器

```java
基本概念：
     JAVAWEB中的监听器是Servlet规范中定义的一种特殊类，
     它用于监听WEB应用程序的ServletContext,HttpSession和ServletRequest等域对象的创建和销毁事件，
     以及监听这些域对象中的属性发生修改的事件
```

#### servlet 的监听器

```java
Servlet规范中定义了多种类型的监听器，它们用于监听事件源分别为ServletContext, HttpSession , ServletRequest这个三个对象。
Servlet规范中针对这个三个对象上的操作，又把多种类型的监听器划分为三种类型。
  1） 监听绑定域对象创建和销毁事件的监听器
  2） 监听域对象中的属性的增加和删除事件监听器
  3） 监听绑定到HttpSession域中的某个对象的状态的事件监听器
```

#### 监听器 API

```java
域对象中属性的变更的事件监听器就是用来监听ServletContext，HttpSession，HttpServletRequest这三个对象中的属性的变更信息事件的监听器

这三个监听器的接口分别是 ServletContextAttributeListener,HttpSessionAttributeListener 和 ServletRequestAttributeListener。这三个接口中都定义了三个方法来处理被监听对象中的属性的增加，删除和替换事件
通一个事件在这三个接口中的对应方法名称完全相同，只是接受的参数类型不同。
```

```java
1）attributeAddes方法
     当向被监听对象中增加一个属性时，web容器就调用事件监听器的attributeAdded方法进行响应，这个方法接受一个事件类型的参数，
     监听器可以通过这个参数来获得正在增加属性的域对象和被保存到域中的属性对象
    各个域监听器中完整语法定义为：
    public void attributeAdded(ServletContextAttributeEvent scae)
    public void attributeReplaced(HttpSessionBindingEvent  hsbe)
    public void attributeRmoved(ServletRequestAttributeEvent srae)

2）attributeRemoved方法
   当删除被监听对象中的一个属性时，web容器调用事件监听器的attributeRemoved方法进行响应
   各个域属性监听器中的完整语法定义为：
   public void attributeRemoved(ServletContextAttributeEvent scae)
   public void attributeRemoved (HttpSessionBindingEvent  hsbe)
   public void attributeRemoved (ServletRequestAttributeEvent srae)

3）attributeReplaced 方法
   当监听器的域对象中某个属性被替换时，web容器调用事件监听器的attributeReplaced方法进行响应
   各个域属性监听器中的完整语法定义为：
    public void attributeReplaced(ServletContextAttributeEvent scae)
    public void attributeReplaced (HttpSessionBindingEvent  hsbe)
    public void attributeReplaced (ServletRequestAttributeEvent srae)
```

#####

##### 监听 ServletContext 域对象的创建和销毁

```java
ServletContextListener 接口用于监听ServletContext对象的创建和销毁事件，
实现了ServletContextListener接口的类都可以对Servlet对象的穿件和销毁进行监听
  当ServletContext对象被创建时，激发contextInitialized（ServletContextEvent sce）方法
  当ServletContext对象被销毁时，激发contextDestoryed（ServletContextEvent sce）方法

ServletContext域对象创建和销毁时机：
  创建：服务器启动针对每一个Web应用创建ServletContext;
  销毁：服务器关闭前先关闭代表每一个web应用的ServletContext

<listener>
        <description> ServletContextListener监听器 </description>
          <!-- 实现ServletContextListener接口的监听器类 -->
       <listener-class >com.listenter.ListenerDemo </listener-class>
 </listener >

public class ListenerDemo implements ServletContextListener {

   @Override 程序启动的时候就执法该方法
   public void contextDestroyed(ServletContextEvent arg0) {
       System. out.println("Servlet APP  已经销毁==============" );
   }

   @Override
   public void contextInitialized(ServletContextEvent arg0) {
       System. out.println("Servlet APP  已经启动================" );
   }
}

```

**ServletContextAttributeListener 监听器范例**

```java
@Override
 protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                      throws ServletException, IOException {
              req.getServletContext().setAttribute( "name", "ssgao" );
              req.getServletContext().setAttribute( "name", "shuo ai lin" );
              req.getServletContext().removeAttribute( "name");
       }

@WebListener("ServletContextDemo" )
public class ServletContextDemo implements ServletContextAttributeListener {

        @Override
        public void attributeAdded(ServletContextAttributeEvent arg0) {

              String string = MessageFormat. format("ServletContext域对象中添加了属性：{0}，属性值是：{1}" , arg0.getName(),arg0.getValue());
              System. out.println(string);
       }

        @Override
        public void attributeRemoved(ServletContextAttributeEvent arg0) {
              String string = MessageFormat. format("ServletContext域对象中删除了属性：{0}，属性值是：{1}" , arg0.getName(),arg0.getValue());
              System. out.println(string);

       }

        @Override
        public void attributeReplaced(ServletContextAttributeEvent arg0) {
              String string = MessageFormat. format("ServletContext域对象中修改了属性：{0}，属性值是：{1}" , arg0.getName(),arg0.getValue());
              System. out.println(string);

       }

}
```

#####

##### 监听 HttpSession 域对象的创建和销毁

```java
HttpSessionListener接口用于监听HttpSession对象的创建和销毁
创建一个Session时，激发sessionCreated(HttpSessionEvent se)方法
销毁一个Session时，激发sessionDestoryed(HttpSessionEvenet se)  方法

Session对象的创建，在服务器启动的时候并没有创建Session而是在调用页面，通过request.getSession（）才创建Session

  <listener >
       <listener-class >com.listenter.SessionListener </listener-class>
  </listener >
  <session-config >
        设置过时时间为1分钟
       <session-timeout >1 </session-timeout>
  </session-config >

public class SessionListener implements HttpSessionListener {

        @Override
         一般在访问页面时才创建session
        public void sessionCreated(HttpSessionEvent arg0) {
              System. out.println("Servlet SESSION  已经启动==============" );
       }

        @Override
        public void sessionDestroyed(HttpSessionEvent arg0) {
              System. out.println("Servlet SESSION  已经销毁==================" );
       }

}
```

##### 监听 ServeltRequest 对象的创建和销毁

```java
Request对象被创建时，监听器的requestInitialized（ServletRequestEvent sre）方法将被被调用
Request对象呗销毁时，监听器的requestDestoryed（ServeltRequestEvent sre）方法将被调用

ServletRequest域对象创建和销毁时机
创建：用于每一次访问都会创建request对象 (每一次请求页面时)
销毁：当前访问结束，request对象就会销毁（一般是页面打开完成后）

 <listener >
      <listener-class >com.listenter.RequestListener </listener-class>
 </listener >

public class RequestListener implements ServletRequestListener {

        @Override
        public void requestDestroyed(ServletRequestEvent arg0) {
               // TODO Auto-generated method stub
              System. out.println(arg0.getServletRequest()+"destory" );
       }

        @Override
        public void requestInitialized(ServletRequestEvent arg0) {
               // TODO Auto-generated method stub
              System. out.println(arg0.getServletRequest()+"init" );
       }
}
```

**ServletRequestAttributeListener 和 HttpSessionAttributeListener 监听器范例**​

```java
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                      throws ServletException, IOException {


              req.setAttribute( "name", "ssgao" );
              req.getSession().setAttribute( "name", "ssgao" );

              req.setAttribute( "name", "lin" );
              req.getSession().setAttribute( "name", "lin" );

              req.removeAttribute( "name");
              req.getSession().removeAttribute( "name");
       }


@WebListener("AttribueDemo" )
public class AttributeDemo implements ServletRequestAttributeListener,
              HttpSessionAttributeListener {

        @Override
        public void attributeAdded(HttpSessionBindingEvent arg0) {
              String str =MessageFormat. format("Session域对象中添加了属性:{0}，属性值是:{1}" ,arg0.getName(),arg0.getValue());
              System. out.println(str);
       }

        @Override
        public void attributeRemoved(HttpSessionBindingEvent arg0) {
              String str =MessageFormat. format("Session域对象中删除了属性:{0}，属性值是:{1}" ,arg0.getName(),arg0.getValue());
              System. out.println(str);
       }

        @Override
        public void attributeReplaced(HttpSessionBindingEvent arg0) {
              String str =MessageFormat. format("Session域对象中修改了属性:{0}，属性值是:{1}" ,arg0.getName(),arg0.getValue());
              System. out.println(str);
       }

        @Override
        public void attributeAdded(ServletRequestAttributeEvent arg0) {
              String str =MessageFormat. format("Request域对象中添加了属性:{0}，属性值是:{1}" ,arg0.getName(),arg0.getValue());
              System. out.println(str);
       }

        @Override
        public void attributeRemoved(ServletRequestAttributeEvent arg0) {
              String str =MessageFormat. format("Request域对象中删除了属性:{0}，属性值是:{1}" ,arg0.getName(),arg0.getValue());
              System. out.println(str);
       }

        @Override
        public void attributeReplaced(ServletRequestAttributeEvent arg0) {
              String str =MessageFormat. format("Request域对象中修改了属性:{0}，属性值是:{1}" ,arg0.getName(),arg0.getValue());
              System. out.println(str);
       }

}
```

​

#### 监听器的注解

```java
Servlet3.0下的监听器的用法

@WebListener
该注解将类声明为监听器，被@WebListener标注的类必须实现以下至少一个接口
ServletContextListener
ServletContextAttributeListener

HttpSessionListener
HttpSessionAttributeListener

ServletRequestListener
ServletRequestAttributeListener
```

**_@WebListener 的常用属性_**​
![image.png](https://cdn.nlark.com/yuque/0/2021/png/659846/1635732185789-3b50c221-5c15-48eb-872c-edc4f1481d13.png#clientId=ua71ffd24-cc51-4&from=paste&height=69&id=u71d8aa7f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=68&originWidth=695&originalType=binary&ratio=1&size=6825&status=done&style=none&taskId=u7c2fe39e-7261-45ba-9e53-ce32d30f273&width=703.5)

```java
@WebListener("ServletContext" )
public class ListenerDemo implements ServletContextListener { ..... }

@WebListener("Session" )
public class SessionListener implements HttpSessionListener { .... }

@WebListener("Request" )
public class RequestListener implements ServletRequestListener { ... }
```

#### 监听器的启动顺序

![image.png](https://cdn.nlark.com/yuque/0/2021/png/659846/1635732319614-8d285c6b-fc32-4a5d-854b-4e4752e56553.png#clientId=ua71ffd24-cc51-4&from=paste&height=317&id=u5d6c3b54&margin=%5Bobject%20Object%5D&name=image.png&originHeight=640&originWidth=1256&originalType=binary&ratio=1&size=578874&status=done&style=none&taskId=ufd62f52c-b7d3-45b2-994b-55519d05d2e&width=622)

#### 特殊的 session 监听器

```java
保存在Session域中的对象可以有多种状态：
   绑定（session.setAttribute("bean".Object)）到Session中，从Session域中结束Session.removeAttribute("bean")绑定
   随Session对象持久化到一个存储设备中；随Session对象从一个存储设备中恢复
 Servlet规范中定义了两个特殊的监听器接口
   HttpSessionBindingListener 和  HttpSessionActivationListener来帮组JavaBean对象了解自己在Session域中的这些状态
   		实现两个接口的类不需要在web.xml文件中进行注册

```

##### HttpSessionBindingListener 接口

```java
实现了httpSessionBindingListener接口的JavaBean对象可以感知自己被绑定到Session中和Session中删除的事件

1）当对象被绑定到HttpSession对象中时
	web服务器调用该对象的 void valueBound(HttpSessionBindingEvent event)方法
2）当对象从HttpSession对象中解除绑定时
	web服务器调用该对象的 void valueUnbound(HttpSessionBindingEvent event)方法

```

```java
public class BindSession implements HttpSessionBindingListener{
       private String name ;

       public BindSession(String name){
               this.name = name;
       }
       @Override
       public void valueBound(HttpSessionBindingEvent arg0) {
              System. out.println("name=" +name +",被添加到Session中" );
       }
       @Override
       public void valueUnbound(HttpSessionBindingEvent arg0) {
              System. out.println("name=" +name +",被从Session中移出" );
       }
}

 @Override
 protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                      throws ServletException, IOException {
     req.getSession().setAttribute( "name", new BindSession( "ssgao"));
     		//name=ssgao,被添加到Session中
     req.getSession().removeAttribute( "name");
     		//name=ssgao,被从Session中移出

}
```

​

##### HttpSessionActivationListener 接口

```java
/**
      实现了HttpSessionActivationListener接口的 JavaBean 对象可以感知自己被活化和钝化的事件
      活化: javabean对象和Session一起被反序列化(活化)到内存中。
     钝化: javabean对象存在Session中，当服务器把session序列化到硬盘上时，如果Session中的 javabean对象实现了Serializable接口
     那么服务器会把session中的 javabean对象一起序列化到硬盘上， javabean对象和Session一起被序列化到硬盘中的这个操作称之为钝化
     如果Session中的 javabean对象没有实现 Serializable接口，那么服务器会先把Session中没有实现 Serializable接口的javabean对象移除
     然后再把Session序列化(钝化)到硬盘中
     当绑定到 HttpSession对象中的 javabean对象将要随 HttpSession对象被钝化之前，
     web服务器调用该 javabean对象对象的 void sessionWillPassivate(HttpSessionEvent event)方法
     这样 javabean对象就可以知道自己将要和 HttpSession对象一起被序列化(钝化)到硬盘中
     当绑定到HttpSession对象中的 javabean对象将要随 HttpSession对象被活化之后，
     web服务器调用该 javabean对象的 void sessionDidActive(HttpSessionEvent event)方法
     这样 javabean对象就可以知道自己将要和 HttpSession对象一起被反序列化(活化)回到内存中
 */
public class JavaBeanDemo02 implements HttpSessionActivationListener, Serializable {

   private static final long serialVersionUID = 123456L;
   private String nameString ;
   @Override
   public void sessionDidActivate(HttpSessionEvent arg0) {
       System. out.println(nameString +"和session一起从硬盘反序列化(活化)回到内存了，session的id是：" +arg0.getSession().getId());
   }

    @Override
    public void sessionWillPassivate(HttpSessionEvent arg0) {
        System. out.println(nameString +"和session一起被序列化(钝化)到硬盘了，session的id是：" +arg0.getSession().getId());
    }

    public String getNameString() {
        return nameString ;
    }

    public void setNameString(String nameString) {
        this.nameString = nameString;
    }

    public JavaBeanDemo02(String nameString){
        this.nameString = nameString;
    }
}

```

​

```java
为了观察绑定到HttpSession对象中的javabean对象，随HttpSession对象一起被钝化到硬盘上和从硬盘上重新活化到内存中的过程，我们需要借助tomcat服务器帮组我们完成HttpSession对象的钝化和活化过程
做法：
     1）在WebRoot\META-INF文件夹下，创建一个context.xml文件
     2）内容：
          <?xml version= "1.0" encoding ="UTF-8"?>
<Context>
    <Manager className="org.apache.catalina.session.PersistentManager" maxIdleSwap="1" >
               <Store className="org.apache.catalina.session.FileStore" directory="ssgao" />
    </Manager >
</Context>

<Context>
    <Manager className="org.apache.catalina.session.PersistentManager"
    		maxIdleSwap="1"[如果session在1分钟内没有使用，那么Tomcat就会钝化它]>
        <Store className="org.apache.catalina.session.FileStore" directory="mysession"[把session序列化到Tomcat\work\Catalina\localhost\listener\mysession目录下。]/>
    </Manager>
</Context>
```

​

​

​

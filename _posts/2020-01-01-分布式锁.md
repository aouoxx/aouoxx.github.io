---
layout: post
title: 分布式锁
categories: 分布式
description: 分布式锁
keywords: 分布式
---

<meta name="referrer" content="no-referrer"/>
​

​

### 常见的分布式锁

```java
基于数据库实现分布式锁
基于缓存(Redis,memcached,tair)实现分布式锁
基于zookeeper实现分布式锁

分布式锁的作用
    可以保证在分布式部署的应用集群中,同一个方法在同一个时间只能被一台机器上的一个线程运行。
    这把锁是一个可重入锁(避免死锁)
    根据不同的业务场景设置是不是阻塞锁
    高可用的获取锁和释放锁
    获取锁和释放锁的性能要好


```

#### 基于数据库的分布式锁

```java
通过创建数据库表和数据记录来实现分布式锁
    要实现分布式锁,最简单的方式可能就是直接创建一张锁表,然后通过操作该表中的数据来实现
    创建一张数据库表
        create table method_lock(
            id,  //主键
            method_name, //锁定的方法名 unique key 唯一性约束
            desc,  //备注信息
            update_time //保存时间,自动生成
        )。
     当我们需要要锁住某个方法的时候,执行以下sql语句
         insert into method_lock(method_name,desc) values ('method_name','desc');
     因为我们对method_name做了唯一性约束,这里如果有多个请求提交到数据库的话,数据库会保证只有一个操作成功
     我们认为操作成功的那个线程获得了该方法的锁,可以执行方法体内容。
     当方法执行完毕后,想要释放锁的话,需要执行以下sql
         delete from method_lock where method_name='method_name';

    上面简单的实现会出现以下几个问题
    1> 这把锁强依赖数据库的可用性,数据库是一个单点,一旦数据库挂了,会导致业务系统不可用
    2> 这把锁没有失效时间,一旦解锁操作失败,就会导致锁记录一直在数据库中,其他线程无法在获得锁。
    3> 这把锁只能是非阻塞的,因为数据的insert操作,一旦插入失败就会直接报错。没有获取锁的线程并不会进入排队队列,要想再次获取锁就需要再次触发。
    4> 这把锁是非重入锁,同一个线程,在没有释放锁之前无法再去获得该锁。因为数据库已经存在了。
    解决方式
    1> 数据库单点,就搞两个数据库,数据之前双向同步。一旦挂掉快速切换到备份库上。
    2> 没有失效时间, 做一个定时任务,没隔一定时间把数据库中超时数据清理一遍。
    3> 非阻塞的, 搞一个while循环,知道insert成功在返回成功。
    4> 非重入的, 在数据库表中加个字段,记录当前获得锁的机器主机信息和线程信息,那么下此获取锁的时候先检查数据中是否有当前数据和线程信息,就直接获取锁。


通过数据库自带的'排他锁'来实现分布锁
    基于MySQL的InnoDB引擎,可以使用以下方法来实现加锁操作。
    public boolean lock(){
        connection.setAutoCommit(false);
        while(true){
            try{
                result = select * from method_lock where method_name=xxx for update;
                if(result==null){
                    return true;
                }
            }catch(Exception e){
                //xxxx；
            }
            sleep(1000);
        }
        return false;
    }
    这里查询语句后面增加 for update,数据库后再查询过程中给数据库加上排他锁,某条记录被加上排他锁以后,其他线程不能再该行记录上添加排他锁。
    我们可以通过排他锁的方式获取分布式锁,当获取锁以后,执行方法的业务逻辑,执行完方法之后,再通过以下方法解锁:
     public void unlock(){
         connection.commit(); //通过connection.commit()来释放锁。
     }
     这种方式解决了上面无法释放锁和阻塞锁的问题。
     阻塞锁解决的原因,因为for update会在执行成功之后立即返回,执行失败一直处于阻塞状态,直到成功。
     释放锁的原理,锁定之后服务冗机,无法释放,这种方式在服务冗机后数据库自己把锁释放掉,但是还是无法直接直接数据库单点问题和可重入问题。


基于数据库锁的优缺点
    总结:使用数据来实现分布式锁的方式,两种方式都是依赖数据中的一张表,来实现的。
            一种是通过表中记录存在情况确定当前是否有锁存在
            一种是通过数据库的排它锁
    优点: 直接借助数据库,容易理解
    缺点: 各种各样的问题,使得整个方案很复杂
          操作数据需要一定的开销,性能问题也需要考虑
```

#### 基于 redis 的分布式锁

```java
目前很多城市的缓存产品,redis,memcaches。缓存可以是集群部署,从而解决了单点问题。

    缓存使用同样存在几个问题:
        1> 锁没有失效时间,一旦解锁操作失败,就会导致记录一直存在,其他线程无法再获取锁
        2> 锁只能是非阻塞的,无论成功还是失败都直接返回
        3> 锁是非重入的,一个线程获得锁之后,在释放锁之前,无法再次获取该锁,因为使用的key在内存中已经存在,无法在执行put操作
    解决方式:
        1> 失效时间 put支持传入失效时间,到达时间之后数据就会自动删除
        2> 非阻塞 使用while重复执行
        3> 非可重入 在一个线程获取锁之后,把当前主机信息和线程保存起来,下载再次获取的时候先检查自己的是不是当前锁的拥有者。
    使用总结和优缺点
    总结:使用缓存代理数据库实现分布式锁,可以提供更好的性能,很多缓存服务都是集群部署的,可以避免单点问题。
        很多缓存服务都提供了可以用来实现分布式锁的方法,比如redis的setnx方法等。
        并且缓存服务器也都提供了对数据的过期自动删除功能,直接设置超时时间来控制锁的释放。
    优点:性能好,实现起来比较方便
    缺点:使用超时时间来控制锁的失效时间并不十分靠谱。
         设置太短,方法没执行完,锁就自动释放了,就会产生并发问题
         设置太长,其他线程可能要平白多等待一段时间。(这个问题使用数据库实现分布式锁也同样存在)
```

#### 基于 zookeeper 的分布式锁

```java
 每个客户端对某个方法加锁时,在zk上的与该方法对应的指定节点目录下,生成一个唯一的瞬时节点
 判断是否获取锁,只需要判断节点中序号最小的一个。
 当释放锁的时候,只需要将这个瞬时简单删除即可,同时可以避免服务冗机导致锁无法释放,而产生的死锁问题。

 zk解决锁无法释放的问题:
    在创建锁的时候,客户端会在zk中创建一个临时节点,一旦客户端获取锁之后突然挂掉(session连接断开),那么这个临时节点就会自动删除。其他客户端可以在此获取锁
 zk非阻塞锁的问题:
    客户端可以在zk上创建顺序节点,并且在该节点上绑定监听器,一旦节点有变化,ZK会通知客户端,客户端就可以检查自己创建的节点是不是当前节点中序号最小的
    如果是,那么自己就获取得到锁,便可以执行业务逻辑了
 zk不可重入问题:
    使用zk也可以有效的解决不可重入的问题,客户端在创建节点的时候,把当前客户端的主机信息和线程信息直接写到节点中
    下次想要获取锁的时候和最小节点数据对比下就可以了。如果和自己的信息一样,那么自己直接获取到锁,如果不一样就在创建一个临时顺序节点参与排队。

  curator客户端,封装的一个可重入锁服务(InterProcessMutex分布式锁的实现)
      public boolean tryLock(long timeout,Timeunit) throws Exception{
          try{
              return interProcessMutex.acquire(timeout,unit); //获取用户锁
          }catch(Exception e){
              e.printStackTrace();
          }
      }
      public boolean unlock(){
          try{
              interProcessMutex.release(); //释放锁
          }catch(Throwable e){
              log.error(e.getMessage(),e);
          }finally{
              exectorService.schedule(new Cleaner(client,path),delayTimeForClean,TimeUnit.MILLSECONDS);
          }
          return true;
      }
    zk分布式锁的优缺点:
        优点: 有效解决单点问题,不可重入问题,非阻塞问题以及锁无法释放问题。
        缺点: 每次获取和释放锁的时候,都要动态创建,销毁瞬时节点来实现锁功能。ZK中创建和删除节点通过leader服务器来执行然后再同步到Follower机器上。
              所以性能上不如缓存实现分布式锁
```

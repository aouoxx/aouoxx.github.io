#### 单例模式双重加锁为什么需要加上 volatile 关键字

```java
public class DoubleCheckLocking{
	private static DoubleCheckLocking instance;

    public static DoubleCheckLocking getInstance(){
    	if(instance==null){ //第一检查
        	synchronized(DoubleCheckLocking.class){ // 加锁
            	if(instance==null) { //第二次检查
                	instance = new DoubleCheckLocking(); // 第8行, 问题的根源之处。
                }
            }
        }
        return instance;
    }

}

```

```java
问题:在线程执行到第4行, 代码读到instance不为null时, instance引用的对象有可能还没有完全初始化。
问题的根源:
双重检查锁定 instance = new DoubleCheckLocking() 创建了一个对象。 这一行代码可以分解为下面3行代码。
  memory = alloct(); //1: 分配对象的内存空间
  ctorinstance(memory); //2: 初始化对象
  instance = memory; //3: 设置instance指向刚分配的内存地址
上面3行伪代码2和3之间, 可能被重排序, 重排序如下:
  memory=alloct(); //1: 分配对象的内存空间
  instance=memory; //3: 设置instance指向刚分配的内存地址
  ctorinstance(memory); //2: 初始化对象
```

#### 修改后的写法

```java
public class DoubleCheckedLocking {
    private static volatile DoubleCheckedLocking instance;

    public static DoubleCheckedLocking getInstance(){
        if(instance == null){// 4.第一次检查

            synchronized (DoubleCheckedLocking.class){ // 5.加锁
                if(instance == null){ // 6. 第二次检查
                    instance = new DoubleCheckedLocking(); // 7.问题的根源处在这里
                }
            }
        }
        return instance;
    }
```

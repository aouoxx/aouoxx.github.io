---
layout: post
title: zookeeper深入介绍
categories: zookeeper
description: zookeeper相关原理的深入讲解
keywords: zookeeper
---

<meta name="referrer" content="no-referrer"/>

> _zookeeper 为了保证各个节点的协同工作, 在工作时需要一个 Leader 角色, 而 zookeeper 默认采用 FastLeaderElection 算法, 且投票数大于半数则胜出的机制, 在介绍选举机制前,首先先了解选举涉及的相关概念。_

```java
服务器ID
	这是在配置集群时设置的myid参数文件, 且参数分别表示服务器1, 服务器2, 服务器3 编号越大在FastLeaderElection算法中的权重越大。

选举状态
	在选举过程中, zookeeper服务器有四种状态,它们分别为
    	竞选状态(LOOKING)
    	随从状态(FOLLOWING, 同步Leader状态,参与投票)
    	观察状态(OBSERVING, 同步Leader状态,不参与投票)
    	领导者状态(LEADING)

数据ID
	服务器中存放的最新数据版本号, 该值越大则说明数据越新, 在选举过程中数据月薪权重越大。
```

### 选举机制的类型

```java
zookeeper选举机制有两种类型,分别为全新集群选举和非全新集群选举。

全新集群选举
	全新集群选举是新搭建起来的, 没有数据ID和逻辑时钟的数据影响集群的选举。假设,目前有5台机器,它们的编号分别是1~5, 按编号依次启动ZK服务。下面说明全新集群的选举过程:
	步骤1: 服务器1启动, 首先, 它会给自己投票, 其次 发投票信息, 由于其他机器还没有启动,所以它无法接收到投票的反馈信息, 因此服务器1的状态一直属于LOOKING状态。

    步骤2: 服务器2启动,首先,会给自己投票, 其次在集群中启动zookeeper服务的发起投票对比,这时它会与服务器1交换结果,由于服务器2的编号大,所以服务器2胜出, 此时服务器1会将票投给服务器2, 但此时服务器2的投票数没有大于集群的半数(2<5/2),所以两个服务器的状态依然是LOOKING状态。

    步骤3: 服务器3启动, 首先会给自己投票, 其次与之前启动的服务器1,2交换信息, 由于服务器3的编号最大所以,服务器3胜出, 那么服务器1,2会将票投给服务器3, 此时投票数正好大于半数(3>5/2)所以服务器3称为领导者状态,服务器1,2称为追随者状态。

    步骤4: 服务器4启动, 首先给自己投票, 其次与之前启动的服务器1,2,3交换信息, 尽管服务器4的编号大,但是服务器3已经胜出。所以服务器4智能称为追随者状态。

    步骤5: 服务器5启动,同服务器4一样,均称为追随者状态。

```

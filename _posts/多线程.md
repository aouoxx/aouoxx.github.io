### 锁的分类

#### 分段锁

```
分段锁其实是一种锁的设计,并不是具体的一种锁,对于ConcurrentHashMap而言,其并发的实现就是通过分段锁的形式来实现高效的并发操作。
```

[https://www.cnblogs.com/java-chen-hao/p/9970581.html#\_label1_0](https://www.cnblogs.com/java-chen-hao/p/9970581.html#_label1_0)
[https://blog.csdn.net/jsbylibo/article/details/82465989](https://blog.csdn.net/jsbylibo/article/details/82465989)

#### 锁消除

#### 锁膨胀

#### 锁的使用场景(单例模式)

```java
class MySingle{
    // 声明一个私有的静态变量,第一次调用才初始化,避免内存浪费
	private volatile static Mysingle instance =null;
    //让构造器为private私有化,避免外部直接创建对象
    private Mysingle(){}
    public static MySingle getInstance(){
        // 提高效率,如果已经存在对象,则不进行锁等待,直接返回对象
        // 只有当对象为空才会进入锁等待,这里可以第一个进入锁创建对象后,sleep 10秒来放大效果
    	if(null==instance){
            // 这里假设有5个等待线程
        	synchronized(MySingle.class){
                // 第一次,当一个线程进来后,其他线程都在锁外面,第一个线程创建对象后,释放锁,其他线程得到锁,
                // 如果intance不为null,则不需要创建
            	if(null==instance){
                	instance = new Mysingle();
                }
                try{
                	Thread.currentThread().sleep(1000);
                }catch (InterruptedException e){
                	e.printStackTrace();
                }
            }
        }
        return instance;
    }

}
```

```java
偏向锁升级为轻量级锁时, 是两个不同的线程通过CAS在用户线程中进行抢占,不设计系统的开销。
```

### 线程的可见性

### CAS 的介绍

#### case 的优缺点

```java
使用CAS的优势在于不需要使用传统的锁机制来保证线程安全, CAS是一种基于忙等待的算法,依赖底层硬件的实现,"相等于锁它没有线程切换和阻塞的额外消耗",可以支持较大的并行度。

CAS的一个重要缺点, 如果忙等待一直执行不成功(一直死循环中),会对CPU造成较大的执行开销。
```

#### case 仅保证一个共享变量原子操作

```java
  当对一个共享变量执行操作时,我们可以使用cas方式来保证原子操作,但是对于多个变量操作时, 循环CAS就无法保证操作的原子性了,这种场景下,我们就需要使用加锁的方式来解决。
```

#### case 自旋消耗资源

```java
这里并不是cas自旋,是外层的for循环
public class Test {
    private static final AtomicReference<Integer> INSTANCE = new AtomicReference<Integer>();
	public void test(){
        for(;;){
        	// 这里cas没有成功,就会陷入自旋,对CPU造成较大的执行开销
            if(INSTANCE.compareAndSet(2,5)){
            	return xx;
            }
        }
    }


```

#### 解密 CAS 底层指令

```java
底层硬件将CAS的多个操作在硬件层面语义实现上,通过一条处理器指令,保证了原子性操作。
这些指令如下:
	1 测试并设置  test-and-set
    2 获取并增加  fetch-and-increment
    3 交换    swap
    4 比较并交换  compare-and-swap
    5 加载连接/条件存储  load-linked/store-conditional


cas的一个使用场景:n++的问题
public class CasAdd{
    public volatile int n;
    public void add(){ n++; }
}
对应的java字节码指令
public void add();
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=1, args_size=1
         0: aload_0
         1: dup
         2: getfield      #2                  // Field n:I
         5: iconst_1
         6: iadd
         7: putfield      #2                  // Field n:I
        10: return
--------------------n++ 被拆分成一下几个指令：
 > 执行getFiled 拿到原始n
 > 执行iadd 进行加1操作
 > 执行putFiled把累加后的值写回n
通过volatile修饰的编程可以保证线程之间的可见性,但并不能保证这3个指令的原子执行,在多线程并发的执行下无法做到线程安全。

"解决方案1:加锁"
public class CasAdd{
    public volatile int n;
    public synchronized void add(){ n++; }  //方案可行,但是性能下降很厉害
}

"解决方案2:CAS (目前最好的一个解决方案)"
以AtomicInteger为例,分析CAS是如何实现和使用的;
public class AtomicInteger extends Number implements java.io.Serializable{
/** Unsafe是CAS的核心类,由于JAVA无法直接访问底层系统,需要通过本地(native)方法来问题,Unsafe就相当于一个后门可以直接操作特定内存的数据 */
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset; //变量内存偏移地址,因为Unsafe就是根据内存偏移地址获取数据的
    private volatile int value; //volatile保证内存可见性,保证多线程之间的内存可见性

    static{
        try{
           valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField("value"));
        }catch(Exception ex){throw new Error(ex);}
    }
    public final int get(){
        return value;
    }
    public final int getAndAdd(int delta){
        return unsafe.getAndAddInt(this,valueOffset,delta);
    }

 /**
   * AtomicInteger里面的value原始值为3,即主内存中AtomicInteger的value为3,根据Java内存模型,线程A,B各自一份value的副本,值为3
   * 线程A通过getIntVolatile(var1,var2)拿到value值3,这时线程A被挂起
   * 线程B也通过getIntVolatile(var1,var2)拿到value值3,运气好,线程B没有被挂起,并执行compareAndSwapInt方法,比较内存值也为3,成功修改内存值为2
   * 这时线程A恢复,执行compareAndSwapInt方法比较,发现自己手里的值(3)和内存值(2)不一致,说明该值已经被其他线程修改过了,只能重新来一遍
   * 重新获取value的值m因为value被volatile修饰,所以其他线程对它的修改,线程A总是能看到,线程A继续执行compareAndSwapInt进行比较替换,知道成功
   * 整个过程中,利用CAS保证了对于value的修改并发安全。
  */
    public final int getAndAddInt(Object obj,long offset, int delta){
        int var5;
        do{
            var5=this.getIntVolatile(obj,offset);
        }while(!this.compareAndSwapInt(obj,offset,var5,var5+delta));
        return var5;
    }
}


unsafe类中的compareAndSwapInt是一个本地方法
public final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);
核心是:
   > 先拿到变量value的内存地址
   > 通过Atomic::cmpxchg(cpu命令) 实现比较替换,其中参数paramInt2是即将更新的值,参数paramInt是原来的值
```

#### cas 的 ABA 问题

```java
"cas的一个缺点就是ABA的问题"
  如果变量V初次读取的时候是A,并且在准备赋值的之后检查到它仍然是A,那能说明它的值没有被其他线程修改过么？
  如果在这段期间曾经被改成B,然后又返回A,那么CAS操作就会误认为它从来没有被修改过。
  针对这种情况,java并发包中提供一个带有标记的原子引用类AtomicStampedReference,它可以通过控制变量值的版本来保证CAS的正确性

```

![image.png](https://cdn.nlark.com/yuque/0/2021/png/659846/1610456518203-35d39318-6bf3-434b-befa-40eccae2f33a.png#align=left&display=inline&height=330&margin=%5Bobject%20Object%5D&name=image.png&originHeight=660&originWidth=1652&size=194054&status=done&style=none&width=826)

```java
CAS中ABA的问题导致的原因,如上图藐视,是CAS过程只简单的进行了"值"的校验,再有些情况下,"值"相同不会引入错误的业务逻辑(例如库存)
有些情况下,"值"虽然相同,却不是原来的数据了,所以需要对CAS进行优化——>'CAS 不能只比对“值”,还必须确保的是原来的数据,才能修改成功'。
常用的解决ABA的方案:
    "版本号"的比对,一个数据一个版本,版本变化,即使值相同,也不应该修改成功。JDK中提供的解决方案:AtomicStampedReference


AtomicStampedReference本质是一个int值作为版本号,每次修改之前先获取这个int值的版本号,等到修改的时候,比较当前版本号和当前线程持有的版本号是否一致
 如果一致进行修改,并将版本号+1(具体加多少可以自己定义),zk中保持数据的一致也是用的这种方式。
AtomicMarkableReference则是将一个boolean值作是否有更改的标记,本质就是它的版本号只有两个,true和false,修改的时候在这两个版本号之间来回切换
 这样做并不能解决ABA的问题,只是会降低ABA问题的发生几率而已。

"AtomicStampedReference的内部实现概述"
public class AtomicStampedReference{
    .......
    //Pair类来封装值和时间戳
    private static class Pair<T> {
        final T reference;
        final int stamp;
        private Pair(T reference, int stamp) {
            this.reference = reference;
            this.stamp = stamp;
        }
        static <T> Pair<T> of(T reference, int stamp) {
            return new Pair<T>(reference, stamp);
        }
    }
   //比较设置,参数依次为:期望值,写入新值,期望时间戳,新时间戳 ,当期望值=当前值,期望时间=现在时间 才写入新值,并更新时间戳
    public boolean compareAndSet(V   expectedReference,V   newReference, int expectedStamp, int newStamp) {
        Pair<V> current = pair;
        return expectedReference == current.reference && expectedStamp == current.stamp &&
            ((newReference == current.reference && newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp)));
    }
  .....
}

//使用案例,某公司给余额少的用户免费充值,每个用户只能充值一次
public class AtomicStampReferenceTest {
    //定义初始值和初始化时间
    static AtomicStampedReference<Integer> money = new AtomicStampedReference<Integer>(19,0);
    public static void main(String[] args) {
        for(int i=0;i<3;i++){
            final int timeStamp = money.getStamp();
            new Thread(){
              public void run(){
                  while (true){
                      Integer m = money.getReference();
                      if(m<20){
                          if(money.compareAndSet(m,m+20,timeStamp,timeStamp+1)){
                              System.out.println("充值成功,余额:"+money.getReference());
                          }
                      }
                  }
              }
            }.start();
        }
        new Thread(){
            public void run(){
                for(int i=0;i<100;i++){
                    while (true){
                        int timestamp = money.getStamp();
                        Integer m = money.getReference();
                        if(m>10){
                            if(money.compareAndSet(m,m-10,timestamp,timestamp+1)){
                                System.out.println("消费10元,余额:"+money.getReference());
                                break;
                            }
                        }else{
                            break;
                        }
                    }
                    try {
                        Thread.sleep(100);
                    }catch (Exception e){

                    }
                }
            }
        }.start();
    }
}
```

### park&unpark

#### 特征介绍

```java
	LockSupport 是非重入的,因为park的意思仅仅是阻塞某个线程而已, 并不是"锁",调用一次park方法,线程就被阻塞了。
	LockSupport的park阻塞, unpark唤醒的调用不需要任何条件对象, 也不需要先获取什么锁。在一定程度上降低代码的耦合度,即LuckSupport只与线程绑定, 并且被park的线程并不会释放之前获取到的锁。
	park阻塞与unpark唤醒的调用顺序可以颠倒,不会出现死锁,并且可以重复多次调用unpark; 而stop和resume方法如果顺序反了,就会出现死锁现象。
    park支持中断唤醒,但是不会抛出InterruptException异常,可以从isInterrupted(不会清除中断标记) interrupted(清除中断标记) 方法中获得中断标记。
  			 thread.isInterrupted();
        	 thread.interrupt();
```

```java

LockSupport类是Java6引入的一个类, 提供了基本的线程同步原语。
LockSupport实际上是调用了Unsafe类里的函数,归结到Unsafe里,只有两个函数:
  public native void unpark(Thread jdthead);
  public native void park(boolean isAbsolute,long time);
	isAbsolute参数 是指明时间是绝对的, 还是相对的。

unpark函数为线程提供"许可(permit)", 线程调用park函数则等待"许可"。有点像信号量,但这个'许可'是不能叠加的,'许可'是一次性的。
比如线程B,连续调用了三次unpark函数,当线程A调用park函数就使用掉这个'许可',如果线程A再次调用park,则进入等待状态。

ps: unpark函数可以先于park调用。比如线程B调用unpark函数,给线程A发一个'许可',那么当线程A调用park时,它发现已经有'许可',那么它会马上再继续执行


```

#### park&unpark 的灵活

```java

根据上面的介绍,unpark函数可以先于park调用,这正是它们的灵活之处。
一个线程它可能在别的线程unPark之前,或者之后,或者同时调用了park, 那么因为park的特性, 它可以不用担心自己的park时序问题。 否则，如果park必须要在unpark之前，就给编程带来很大的麻烦。

考虑一下,两个线程同步,要如何处理?
 在JDK 5里面，是用wait/notify/notifyAll来同步的。wait/notify机制的缺点, 比如线程B要用notify通知线程A, 那么线程B要确保线程A已经在wait调用上等待了,否则线程A可能永远都在等待。另外是调用notify, 还是notifyAll ?
 notify只会唤醒一个线程, 如果错误地有两个线程在同一个对象上wait等待,就又悲剧了,所以为了安全期间,好像只能用notifyAll。
>>> park/unpark模型真正解耦了线程之间的同步,线程之间不再需要一个Object或者其他变量来存储状态,不再需要关心对方的状态。




在JDK 5里面，是用wait/notify/notifyAll来同步的, 它没有LockSupport那样的容忍性，所以JDK7 JUC之后几乎都是采用park与unpark实现。

```

![image.png](https://cdn.nlark.com/yuque/0/2021/png/659846/1610286135990-39491a87-fe70-4772-9109-45eea6fa80a4.png#align=left&display=inline&height=137&margin=%5Bobject%20Object%5D&name=image.png&originHeight=137&originWidth=432&size=8019&status=done&style=none&width=432)

### AQS(同步队列)

```java
  在java.util.concurrent.locks包中有很多Lock的实现类,常用的有ReentranLock,ReadWriteLock(实现类ReetrantReadWriteLock)
  内部实现都依赖AbstractQueuedSynchronized类即AQS。

  public abstract class AbstractQueuedSynchronizer extends
        AbstractOwnableSynchronizer implements java.io.Serializable {
        //等待队列的头节点
        private transient volatile Node head;
        //等待队列的尾节点
        private transient volatile Node tail;
        //同步状态
        private volatile int state;
        protected final int getState() { return state;}
        protected final void setState(int newState) { state = newState;}
        ...
  }
  队列同步器AQS是用来构建锁或其他同步组件的基础框架,内部使用一个int成员变量表示同步状态,通过内置的FIFO队列来完成资源获取线程的排队工作。

  * 其中内部状态state,等待队列的头结点head和尾结点head,都是通过volatile修饰,保证了多线程之间的可见性。
  state的访问方式有三种:
    getState()
    setState()
    compareAndSetState()
  AQS定义两种资源共享方式:
    Exclusive (独占,只有一个线程能执行,如ReentrantLock)
    Share(共享,多个线程可同时执行,如Semaphare/CountDownLatch)
  自定义同步器在实现的时候,只需要实现共享资源的state的获取与释放方式即可,置于具体线程等待队列的维护(如获取资源失败入队/唤醒出队),AQS已经在顶层实现好了。
  自定义同步器实现是主要实现以下几种方法:
    isHeldExlusively()   该线程是否正在独占资源,只有用到condition才需要实现它。
    tryAcquire(int)      独占方式。尝试获取资源,成功返回true,失败返回false.
    tryRelease(int)      独占方式。尝试释放资源,成功则返回true,失败则返回false.
    tryAquireShared(int) 共享方式。尝试获取资源,负数表示失败,0表示成功,但没有剩余可用资源;正数表示成功,有剩余资源
    tryReleaseShared(int)共享方式。尝试释放资源,释放后允许唤醒后续等待的节点,返回true,否则返回false.
  应用实例介绍:
  ReentrantLock为例,state初始化为0,表示锁定状态。A线程lock()时,会调用tryAcqurie()独占锁,并将state+1。此后,其他线程在tryAcqure()就会失败,
    直到线程A调用unlock()使得state=0(释放锁)为止,其他线程才有机会获取该锁。释放锁之前,A线程自己可以重复获取该锁(可重入,state会累加)。
    需要注意的是获取多少次,就要释放多少次,这样才能保证state能回到零态的。

  一般来说,自定义同步器要么是独占方式,要么是共享方式,他们也只需要实现tryAcqure-tryRelease,tryAcquireShared-tryReleaseShared中的一种即可。
  tryAcqure-tryRelease,tryAcquireShared-tryReleaseShared在同步器并没有声明为abstract,因为在独占或共享模式下其中的一对方法即可,如果都声明为abstract
  那么每个模式也去实现另一个模式的接口,为了避免不需要方法的实现,所以Aqs将其没有声明为abstract.

  AQS也支持自定义同步器同时实现独占和共享两种方式如,ReentrantReadWriteLock




```

![image.png](https://cdn.nlark.com/yuque/0/2021/png/659846/1610588280640-5025f3f1-42d2-4d27-bc6b-43ce809f5b8c.png#align=left&display=inline&height=393&margin=%5Bobject%20Object%5D&name=image.png&originHeight=786&originWidth=1718&size=181032&status=done&style=none&width=859)

```java
static final class Node {
        static final Node SHARED = new Node();
        static final Node EXCLUSIVE = null;
        // 因为超时或者中断,结点处于取消状态(线程已被取消),被取消的结点(线程),不应该去竞争锁
        // 处于这种状态的结点(线程)会被踢出队列,被GC回收
        static final int CANCELLED =  1;
        // 表示结点的后续结点被阻塞了,需要被唤醒(unpark)
        static final int SIGNAL    = -1;
        // 表示结点(线程)在条件队列中(处于condition休眠状态),在等待Condition唤醒
        static final int CONDITION = -2;
        // 使用共享模式下结点有可能处于这种状态,表示锁的下一次获取可以被无条件传播
        static final int PROPAGATE = -3;
        // 为0时,新节点会处于这种状态

        // waitState 一个32位的整型常量,该状态为与线程状态密切相关。
        volatile int waitStatus;
        volatile Node prev; // 前继结点
        volatile Node next; //后继结点
        volatile Thread thread;
        Node nextWaiter;
        ...
        Node() {}
        Node(Thread thread, Node mode) {
            this.nextWaiter = mode;
            this.thread = thread;
        }
        Node(Thread thread, int waitStatus) {
            this.waitStatus = waitStatus;
            this.thread = thread;
        }

        // 当前节点的前驱节点
        final Node predecessor() throws NullPointerException {
            Node p = prev;
            if (p == null)
                throw new NullPointerException();
            else
                return p;
        }
    }
}
```

```java
public abstract class AbstractOwnableSynchronizer implements java.io.Serializable {
    //当前节点的序列化号
    private static final long serialVersionUID = 3737899427754241961L;

    protected AbstractOwnableSynchronizer() { }
    // 当前资源的独占资源
    private transient Thread exclusiveOwnerThread;
    // 设置当前独占资源的线程信息
    protected final void setExclusiveOwnerThread(Thread thread) {
        exclusiveOwnerThread = thread;
    }
    // 获取当前线程的独占资源的线程信息
    protected final Thread getExclusiveOwnerThread() {
        return exclusiveOwnerThread;
    }
}
```

![image.png](https://cdn.nlark.com/yuque/0/2021/png/659846/1610588426533-9a39a750-3831-4315-9267-d106184e0eda.png#align=left&display=inline&height=326&margin=%5Bobject%20Object%5D&name=image.png&originHeight=652&originWidth=1838&size=104258&status=done&style=none&width=919)

### 线程概念

#### 线程的重要方法

```java
sleep(long mills)
    调用此方法,当前线程放弃CPU资源,在指定时间内,sleep所在的线程不会获得可运行的机会,此状态下线程不会释放锁。

wait()
   一旦一个线程指定到wait(),就释放当前的锁。
   注意此方法必须在同步代码块或同步方法中。

notify()/notifyAll()
    <<唤醒wait的一个或所有的线程>>
    "此方法需和wait()成对使用",必须在同步代码块或同步方法中

 ps: sleep()和wait()的区别,sleep指定时间内当前线程放弃CPU资源,线程不会释放同步锁,wait会放弃CPU资源,同时也会释放同步锁

 join()
     表示整个线程等待另一个线程完成(死亡)后才执行,join方法被调用之后,线程处于阻塞状态。
     写在哪个线程中,哪个线程阻塞,这种也称为联合线程,也就是说把当前线程和当前线程所在的线程联合成一个线程。

 yield()
     表示当前线程对象提示调度器自己愿意让出CPU资源
     调用该方法后,线程对象进入就绪状态,所以完全有可能某个线程调用了yield()方法,显示线程调度器又把它调度出来重新执行。

 sleep()和yield()方法区别:
	1) 都能使当前处于运行状态的线程放弃CPU资源,把运行的机会给其他线程
    2) sleep方法会给其他线程运行的机会,但不考虑其他线程的优先级;yield方法会优先给更高优先级的线程运行机会
    3) 调用sleep方法后,线程进入计时等待状态,调用yield方法后,线程进入就绪状态
```

#### sleep&&wait

```java
sleep()方法和wait()方法区别:
	1) sleep方法是Thread对象中定义的方法,而wait()方法定义在Object类中
    2) sleep方法可以在任意地方调用,但是wait()方法必须位于同步代码块或者同步方法中。
    3) 线程在sleep的时候,并不会释放锁, 因此其他线程无法获取到锁, 因此也无法执行。而wait方法在执行的时候会释放锁
    因此其他线程可以获取到锁,有机会运行。
```

```java
public class TestPrintNum{
	public static void main(String[] args){
    	PrintNum printNum = new PrintNum();
        Thread thread1 = new Thread(printNum);
        Thread thread2 = new Thread(printNum);
        thread1.start();
        thread2.start();
    }
}
class PrintNum implements Runnable{
	int num=1;
    public void run(){
    	while(true){
        	synchronized(this){
            	notify();
                if(num<=100){
                	try{
                    	Thread.sleep(100);
                    }catch (InterrputedException e){
                    	e.printStackTrace();
                    }
                    System.out.println(Thread.currentTread().getName()+":"+num++);
                }else{
                	break;
                }
                try{
                	wait();
                }catch(InterruptedException e){
                	e.printStackTrace();
                }
            }
        }

    }
}

运行结果分析
	当第一个线程获取锁之后,打印后wait()释放锁。
    第二个线程获取锁,并唤醒第一个线程,打印后wait();交替打印
```

###

#### 程序启动至少有几个线程

```java


每当使用java命令执行一个类的时候,都会启动一个jvm, 每一个jvm实际上就是在操作系统中启动一个进程。
java 本省具备垃圾回收机制,所以每个java运行时,有"main线程" 还有 "垃圾回收机制"的线程

具体的详细信息(以JDK1.8为例)
    1) main  //主线程
    2) Reference Handler  // 清除reference的线程
    3) Finalier  // 调用对象的finalize方法的线程,就是垃圾回收线程
    4) Signal Dispatcher // 分发处理发送给JVM信号的线程
    5) Attach Lister // 与 Singal Dispatcher 一起处理 jmap, jstack等

```

### 线程组

```java
ThreadGroup 来表示线程组, 它可以对一批线程进行分类管理。对线程组的管理,即同时控制线程组里面的这一批线程。

*) 用户创建的所有线程都属于指定线程组, 如果没有显示指定属于哪个线程组,那么该线程就属于默认线程组(即: main线程组)。默认情况下,子线程和父线程处于同一个线程组。
*) 只有在创建线程时候才能指定其所在的线程组,线程运行过程中,不能改变它所属的线程组,也就是说线程一旦指定所在的线程组, 就直到该线程结束。

构造方法:
ThreadGroup(String name) 以指定线程组名字来创建新线程组
ThreadGroup(ThreadGroup parent,String name) 以指定的名字,指定的父线程组来创建一个新线程组

常用操作方法:
int activeCount() 获取线程组中活动线程的数量
interrupt() 中断线程组中所有线程
isDaemon() 是否为后台线程组
setDaemon(boolean daemon) 设置为后台线程组
setMaxPriority(int pri) 设置线程组的最高优先级

```

```java
public class ThreadGroupDemo {

    public static void main(String[] args) {
        // 获取主线程所在的线程组, 这是所有线程默认的线程组
        ThreadGroup group = Thread.currentThread().getThreadGroup();
        System.out.println(String.format("线程组的名字: %s",group.getName())); //main
        /**
         * 构造方法
         * ThreadGroup(String name) 以指定线程组名来创建新线程组
         * ThreadGroup(ThreadGroup parent,String name)
         *      以指定的名字,指定的父线程组来创建一个新的线程组
         *      父线程组为当前线程的线程组名
         */
        ThreadGroup myNewGroup = new ThreadGroup("新线程组");
        myNewGroup.setDaemon(true); //设置为后台线程
        MyThread thread = new MyThread(myNewGroup,"myThread");
        thread.start();
        System.out.println(thread.getThreadGroup().getName());
        System.out.println(thread.getThreadGroup().getParent().getName());

    }

    public static class MyThread extends Thread{
        // 指定线程名,线程组名的构造器
        public MyThread(ThreadGroup group, String name) {
            super(group, name);
        }
        @Override
        public void run() {
            System.out.println("线程执行~");
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

#### 未处理的异常

```java
ThreadGroup 内定义了一个方法: void uncaughtException(Thread t,Throwable e), 该方法可以处理该线程组内的任意线程所抛出的未处理异常。

ThreadGroup类实现了Thread.UncaughtExceptionHandler接口, 所以每个线程所属的线程组将会作为默认的异常处理器。当一个线程抛出未处理异常时,JVM会首先查找该异常对应的异常处理器处理该异常;否则, JVM将会调用该线程所属的线程组对象的uncaughtException() 方法来处理该异常; 否则,JVM将回调用该线程所属的线程组对象的uncaughtException()方法来处理该异常。
```

```java
public class ThreadDemoException {
    public static void main(String[] args) {
        Thread.currentThread().setUncaughtExceptionHandler(new MyExHandler());
        int a = 5/0;
        System.out.println("程序正常结束~~");
    }
    // 定义自己的异常处理器
    public static class MyExHandler implements Thread.UncaughtExceptionHandler{
        // 实现uncaughtException方法, 该方法将处理线程的未处理异常
        @Override
        public void uncaughtException(Thread t, Throwable e) {
            System.out.println(t + " 线程出现了异常: "+e);
        }
    }
}
```

#### 线程组和线程池的区别

```java
线程组是为了方便线程的管理
线程池是为例管理线程的生命周期,复用线程,减少创建销毁线程的开销。
```

### Future&FutureTask

###

#### FutureTask

```
FutureTask是一个支持取消行为的异步任务执行器。该类实现了Future接口的方法如:
   1) 取消任务执行
   2) 查询任务是否执行完成
   3) 获取任务执行结果("get"任务必须得执行完成才能获取结果,否则会阻塞直到任务完成)

FutureTask实现了Runnable接口和Future接口,因此FutureTask可以传给到线程对象Thread或Executor(线程池)来执行。
如果在当前线程中需要执行比较耗时的操作，但又不想阻塞当前线程时，可以把这些作业交给FutureTask，另开一个线程在后台完成，当前线程将来需要时，就可以通过FutureTask对象获得后台作业的计算结果或者执行状态。
```

#### Future

```java
public interface Future<V>{
	// 取消任务
    boolean cancel(boolean mayInterruptIfRunning);
    // 判断任务是否已经取消
    boolean isCancelled();
    // 判断任务是否结束(执行完或取消)
    boolean isDone();
    // 阻塞式获取任务执行结果
    V get() throws InterruptedException, ExecutionException;
    // 支持超时获取任务执行结果
    V get(long timeout,TimeUnit unit) throws InterruptedException,ExecutionException,TimeoutException;

}
```

### ThreadPoolExecutor

#### 线程池的构造函数

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    // 这几个参数都是必须要有的
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();

    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}


corePoolSize  线程池核心线程数
maximumPoolSize 最大线程数,线程池允许创建的最大线程数。
	如果当前阻塞队列满了,且继续提交了任务,则创建新的线程执行任务,前提是当前线程数小于maxmumPoolSize。
    如果阻塞队列是无界队列,则maximumPoolSize则不起作用,因为无法提交至核心线程池的线程会一直持续的放入workQueue

workQueue
	ArrayBlocingQueue 基于数组结构的有界阻塞队列,按FIFO排序任务
    LinkedBlockingQueue 基于链表结构的阻塞队列,按FIFO排序任务,吞吐量通常高于ArrayBlocingQueue
    SynchronousQueue 一个不存储元素的阻塞队列, 每个插入操作必须等到另一个线程调用移除操作,否则插入操作一直处于阻塞状态,吞吐量通常高于LinkedBlockingQueue
    PriorityBlockingQueue 具有优先级的无界阻塞队列

 KeepAliveTime
 	空闲线程的保活时间,如果某个线程的空闲时间超过这个值都没有任务给他做,那么可以被关闭了。
    注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 allowCoreThreadTimeOut(true)使核心线程数内的线程也可以被回收；默认情况下，该参数只在线程数大于corePoolSize时才有用, 超过这个时间的空闲线程将被终止。

unit
	keepAliveTime的单位

threadFactory
	用于生成线程,一般我们可以使用默认的就可以了。
    通常，我们可以通过它将我们的线程的名字设置得比较可读一些，如 Message-Thread-1， Message-Thread-2 类似这样。

handler
	线程池的饱和策略,当阻塞队列满了,且没有空闲的工作线程,如果继续提交任务,必须采取一种策略处理该任务,线程池提供了四种策略。
    AbortPolicy  直接抛出异常,默认策略
    CallerRunsPolicy 用调用者所在的线程来执行任务
    DiscardOldestPolicy  丢弃阻塞队列靠最前的任务,并执行当前任务
    DiscardPolicy  直接丢弃任务
    自定义饱和策略  根据应用场景实现RejectedExecutionHandler接口,自定义饱和策略,如记录日志或持久化存储不能处理任务。
```

#### 线程池的状态

```java
使用一个整形,表示线程池的状态和线程池线程数。
	高位表示状态
    地位表示线程数
"可以深入了解下位操作"

// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数
private static final int COUNT_BITS = Integer.SIZE - 3;
// 000 11111111111111111111111111111
// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911
// 以我们现在计算机的实际情况，这个数量还是够用的
private static final int CAPACITY   = (1 << COUNT_BITS) - 1; 000 11111111111111111111111111111
// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态
private static int runStateOf(int c)     { return c & ~CAPACITY; }
// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数
private static int workerCountOf(int c)  { return c & CAPACITY; }
// runState is stored in the high-order bits
private static final int RUNNING    = -1 << COUNT_BITS; 111 0000000..29个


```

### ScheduleExecutorService

```java
//可调度的执行者服务接口
public interface ScheduledExecutorService extends ExecutorService {
    //指定时延后调度执行任务，只执行一次，没有返回值
    public ScheduledFuture<?> schedule(Runnable command,
                                       long delay, TimeUnit unit);
    //指定时延后调度执行任务，只执行一次，有返回值
    public <V> ScheduledFuture<V> schedule(Callable<V> callable,
                                           long delay, TimeUnit unit);

    //指定时延后开始执行任务，以后每隔period的时长再次执行该任务
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);
    //指定时延后开始执行任务，以后任务执行完成后等待delay时长，再次执行任务
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                     TimeUnit unit);
}
```

```java
scheduleAtFixRate
  	该方法在initialDelay时长后,第一次执行任务,以后每间隔period时长,再次执行任务。
    注意:period是从任务开始执行算起的,开始执行任务后,定时器每隔period时长检查该任务是否完成,如果完成则再次启动任务,否则等该任务结束后才再次启动任务。

scheduleWithFixDelay
	该方法在initialDelay时长后,第一次执行任务,以后每当任务执行完成后,等待delay时长,再次执行任务。
```

#### 构造器

```java
public ScheduleThreadPoolExecutor(int corePoolSize){
    super(corePoolSize,Integer.MAX_VALUE,0,TimeUnit.NUNOSENCENDS, new DelayedWorkQueue());
}
```
